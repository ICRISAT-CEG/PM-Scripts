__author__ = 'jgw87'
"""
Take a number of genetic maps generated by my pipeline and hook them together, calling consensus locations for scaffolds
    -i Comma-separated list of scaffold locations, 1 per genetic map
    -o Output file name with consolidated scaffold locations
    -l Linker file showing which linkage groups correspond across the different maps. Each column should be labeled with
       the name of the corresponding file from -i
"""

import argparse
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import re
import sys

# sys.argv[1:] = ["-i","0_som_scaffolds.txt,0_841_scaffolds.txt",
#                 "-o","2_consensus_linkage_groups.txt",
#                 "-l","1a_lingake_group_equivalencies_MANUAL.txt"]

def main():
    infiles, outfile, linkfile = parse_args()
    linker = make_linker(linkfile)
    scaffolds = load_scaffolds(infiles, linker)
    consensus = consolidate_scaffolds(scaffolds)
    output_consensus(consensus, outfile)


def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument("-i", "--infiles")
    parser.add_argument("-o", "--outfile")
    parser.add_argument("-l", "--linkfile")
    args = parser.parse_args()
    return args.infiles.split(","), args.outfile, args.linkfile


#Load a file showing which LGs match to each across populations
def make_linker(linkfile):
    print("Creating linker structure from",linkfile,"; assuming first column is default")
    linker = dict()
    LINK = open(linkfile, "r")
    #Parse header
    header = LINK.readline().strip().split("\t")    # Separate into entries
    for h in header:
        linker[h] = dict()
    #Parse linkage groups
    for line in LINK:
        lg = line.strip().split("\t")
        for i in range(len(lg)):
            mymap = header[i]
            mylg = lg[i]
            reflg = lg[0]
            linker[mymap][mylg] = reflg
    LINK.close()
    return linker


#Creates a nested dictionary of scaffold -> lg -> count, where count will be used to determine the consensus
def load_scaffolds(infiles, linker):
    scaffolds=dict()
    for infile in infiles:
        print("Loading scaffold data from",infile)

        #Find appropriate columns in header
        IN = open(infile, "r")
        header = IN.readline().strip().split("\t")
        header=np.array(header, dtype=str)
        lgID, scaffoldID = np.where(header=="lg")[0], np.where(header=="scaffold")[0] # [0] b/c np.where returns tuple
        if len(lgID) > 1 or len(scaffoldID) > 1:
            print("WARNING! More than one header column found for linkage groups (",lgID,"or scaffolds",scaffoldID)
        else:   # Reduce to simple ints
            lgID = lgID[0]
            scaffoldID = scaffoldID[0]
        #print("LG at column", lgID, "; scaffold at column",scaffoldID)

        #Parse data line by line
        for line in IN:
            data = line.strip().split("\t")
            data = np.array(data, dtype=str)
            lg, scaffold = data[lgID], data[scaffoldID]
            new_lg = determine_consensus_linkage_group(lg, linker, infile)
            #print("LG",lg,"in",infile,"becomes",new_lg)
            if scaffold not in scaffolds:   # Initialize scaffold
                scaffolds[scaffold] = dict()
            if new_lg not in scaffolds[scaffold]:   #Initialize scaffold->lg
                scaffolds[scaffold][new_lg] = 0
            scaffolds[scaffold][new_lg] += 1
        IN.close()
    return scaffolds


def determine_consensus_linkage_group(lg, linker, infile):
    return linker[infile][lg]


def consolidate_scaffolds(scaffolds):
    print("Determining consensus linkage group by majority rules")
    consensus = dict()
    for scaffold in scaffolds:
        lg = scaffolds[scaffold]
        #print("\t",scaffold, ":",lg)
        for mylg in lg:
            if lg[mylg] > len(lg) / 2:
                consensus[scaffold] = mylg
                #print("\t\tAssigned to",mylg)
    print("\t",len(consensus),"of",len(scaffolds),"assigned (",str(len(consensus)/len(scaffolds)),"%)")
    return consensus

def output_consensus(consensus, outfile):
    print("Outputting results to", outfile)
    #Build lists
    scaffolds, lg = list(), list()
    for scaff in consensus:
        scaffolds.append(scaff)
        lg.append(consensus[scaff])
    output = pd.DataFrame()
    output["scaffold"] = scaffolds
    output["lg"] = lg
    output = output.sort(columns = ["lg", "scaffold"])
    output.to_csv(outfile, sep="\t", index=False)




if __name__ == "__main__":
    main()